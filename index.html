<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover"
/>
<title>Dnepr Airlines</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  :root {
    --inset-top: env(safe-area-inset-top);
    --inset-bottom: env(safe-area-inset-bottom);
    --inset-left: env(safe-area-inset-left);
    --inset-right: env(safe-area-inset-right);
  }
  html, body {
    height: 100%;
  }
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 0;
    background-color: #1a2a6c;
    font-family: 'Courier New', monospace;
    overflow: hidden;
    image-rendering: pixelated;
    padding: var(--inset-top) var(--inset-right) var(--inset-bottom) var(--inset-left);
  }
  .game-container {
    position: relative;
    box-shadow: 0 0 20px rgba(0,0,0,0.5);
    border-radius: 10px;
    overflow: hidden;
    touch-action: none;
  }
  #gameCanvas {
    display: block;
    background-color: #87CEEB;
    border: 5px solid #2a7a8c;
    border-radius: 8px;
    image-rendering: pixelated;
  }
  .score {
    position: absolute;
    top: 10px;
    left: 10px;
    font-size: 24px;
    font-weight: bold;
    color: white;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
    z-index: 5;
    user-select: none;
    -webkit-user-select: none;
    pointer-events: none;
  }
  .start-screen {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background-color: rgba(0,0,0,0.85);
    color: white;
    z-index: 10;
    text-align: center;
    padding: 20px;
    box-sizing: border-box;
  }
  .start-screen h1 {
    font-size: 40px;
    margin-bottom: 20px;
    color: #ffd700;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
  }
  .start-screen p {
    font-size: 16px;
    margin-bottom: 30px;
    max-width: 80%;
    line-height: 1.5;
  }
  .start-button {
    padding: 12px 30px;
    font-size: 20px;
    background-color: #0057b8;
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    font-family: 'Courier New', monospace;
  }
  .start-button:hover {
    background-color: #ffd700;
    color: #0057b8;
    transform: scale(1.05);
  }
  .character-selection {
    display: flex;
    flex-wrap: wrap; /* Allow wrapping */
    justify-content: center;
    gap: 15px;
    margin-bottom: 20px;
  }
  .char-button {
    background-color: rgba(255, 255, 255, 0.1);
    border: 2px solid #ffd700;
    color: white;
    padding: 10px;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-family: 'Courier New', monospace;
    width: 100px;
  }
  .char-button:hover, .char-button.selected {
    background-color: #ffd700;
    color: #0057b8;
    transform: scale(1.05);
  }
  .char-button img {
    width: 60px;
    height: auto;
    image-rendering: pixelated;
  }
</style>
</head>
<body>
  <div class="game-container">
    <div class="score">СЧЕТ: 0</div>
    <canvas id="gameCanvas"></canvas>
    <div class="start-screen">
      <h1>DNEPR AIRLINES</h1>
      <p id="start-screen-p">Выберите персонажа:</p>
      <div class="character-selection">
        <button class="char-button" data-char="benya">
          <img src="benya-letun.png" alt="Benya">
          <span>Беня</span>
        </button>
        <button class="char-button" data-char="moskal">
          <img src="moskal-letun-put.png" alt="Moskal">
          <span>Москаль</span>
        </button>
        <button class="char-button" data-char="porox">
          <img src="porox-letun.png" alt="Porox">
          <span>Порох</span>
        </button>
      </div>
      <button class="start-button" style="display:none;">НАЧАТЬ ПОЛЕТ</button>
    </div>
  </div>
<script>
// ##########################
// NEW: Asset Loading
// We create image objects here and track their loading status.
// ##########################
const roshenLogoImage = new Image();
const planeImage = new Image();
let assetsToLoad = 0; // Starts at 0
let assetsLoaded = 0;
let imageLoaded = false;
function assetLoaded() {
    assetsLoaded++;
    // When all assets are loaded, enable the game
    if (assetsLoaded >= assetsToLoad) {
    if (planeImage.width > 0 && planeImage.height > 0) {
        planeMask = createMask(planeImage);
        planeAspect = planeImage.height / planeImage.width;
    } else {
        console.warn("Plane image not ready yet, skipping mask creation.");
        planeMask = [];
        planeAspect = 1.0;
    }
    imageLoaded = true;
    sizeEverything();
    startScreenP.textContent = `Вы выбрали: ${characterConfigs[selectedCharacter].name}. Нажмите на экран чтобы полетать!`;
    startButton.style.display = 'none';
}
}
// ##########################
// MODIFIED: Character Configuration Object
// Added the new 'porox' character with unique settings.
// ##########################
const characterConfigs = {
    'benya': {
        name: 'Беня',
        imageSrc: 'benya-letun.png',
        gravityMultiplier: 1.0,
        liftMultiplier: 1.0,
        drawObstacle: drawJewishBuilding,
        gameOverText: 'ОЙ, попал в еврейское здание!'
    },
    'moskal': {
        name: 'Москаль',
        imageSrc: 'moskal-letun-put.png',
        gravityMultiplier: 1.0,
        liftMultiplier: 1.0,
        drawObstacle: drawKremlinTower,
        gameOverText: 'ОЙ, попал в кремлевскую башню!'
    },
    // NEW: Porox character config
    'porox': {
        name: 'Порох',
        imageSrc: 'porox-letun.png', // Create this image file
        gravityMultiplier: 1.0, // Heavier, falls faster
        liftMultiplier: 1.0, // Stronger flap
        drawObstacle: drawRoshenPillar,
        gameOverText: 'ОЙ, врезался в Рошен!'
    }
};
let selectedCharacter = null;
// ##########################
// Drawing Helper Functions (No changes here)
// ##########################
function drawStarOfDavid(ctx, x, y, size) { const r = size / 2; ctx.save(); ctx.translate(x, y); ctx.strokeStyle = '#ffd700'; ctx.lineWidth = Math.max(2, size / 10); ctx.beginPath(); for (let i = 0; i < 3; i++) { const angle = Math.PI / 2 + i * (2 * Math.PI / 3); ctx.lineTo(r * Math.cos(angle), r * Math.sin(angle)); } ctx.closePath(); ctx.stroke(); ctx.beginPath(); for (let i = 0; i < 3; i++) { const angle = -Math.PI / 2 + i * (2 * Math.PI / 3); ctx.lineTo(r * Math.cos(angle), r * Math.sin(angle)); } ctx.closePath(); ctx.stroke(); ctx.restore(); }
function drawRedStar(ctx, cx, cy, outerRadius) { const spikes = 5; const innerRadius = outerRadius / 2; let rot = Math.PI / 2 * 3; let x = cx; let y = cy; let step = Math.PI / spikes; ctx.save(); ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius); for (let i = 0; i < spikes; i++) { x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step; x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step; } ctx.lineTo(cx, cy - outerRadius); ctx.closePath(); ctx.lineWidth = 2; ctx.strokeStyle = '#8B0000'; ctx.stroke(); ctx.fillStyle = '#FF0000'; ctx.fill(); ctx.restore(); }
// ##########################
// MODIFIED: Obstacle Drawing Functions
// ##########################
function drawJewishBuilding(ctx, o, width, gap) { ctx.fillStyle = "#ccc"; ctx.fillRect(o.x, 0, width, o.top); ctx.fillStyle = "#99c"; const winRows = Math.max(2, Math.floor(o.top / 24)); const winCols = Math.max(2, Math.floor(width / 18)); for (let r = 0; r < winRows; r++) { for (let c = 0; c < winCols; c++) { ctx.fillRect(o.x + 5 + c * ((width - 10) / winCols), 5 + r * ((o.top - 10) / winRows), 8, 12); } } drawStarOfDavid(ctx, o.x + width / 2, o.top / 2, Math.min(width, 32)); const bottomHeight = canvas.height - (o.top + gap); ctx.fillStyle = "#ccc"; ctx.fillRect(o.x, o.top + gap, width, bottomHeight); ctx.fillStyle = "#99c"; const winRowsB = Math.max(2, Math.floor(bottomHeight / 24)); for (let r = 0; r < winRowsB; r++) { for (let c = 0; c < winCols; c++) { ctx.fillRect(o.x + 5 + c * ((width - 10) / winCols), o.top + gap + 5 + r * ((bottomHeight - 10) / winRowsB), 8, 12); } } drawStarOfDavid(ctx, o.x + width / 2, o.top + gap + bottomHeight / 2, Math.min(width, 32)); }
function drawKremlinTower(ctx, o, width, gap) { ctx.fillStyle = "#c23b22"; ctx.fillRect(o.x, 0, width, o.top); ctx.fillStyle = "#8B0000"; for(let i = 0; i < width; i += 15) { ctx.fillRect(o.x + i, o.top - 10, 8, 10); } drawRedStar(ctx, o.x + width / 2, 30, 18); const bottomHeight = canvas.height - (o.top + gap); ctx.fillStyle = "#c23b22"; ctx.fillRect(o.x, o.top + gap, width, bottomHeight); ctx.fillStyle = "#8B0000"; for(let i = 0; i < width; i += 15) { ctx.fillRect(o.x + i, o.top + gap, 8, 10); } drawRedStar(ctx, o.x + width / 2, o.top + gap + bottomHeight - 30, 18); }
// NEW: Obstacle drawing function for the 'porox' character.
// This function draws a simple pillar and renders the Roshen logo on it.
function drawRoshenPillar(ctx, o, width, gap) {
    const pillarColor = "#7B3F00"; // Chocolate brown color
    // --- Top Pillar ---
    ctx.fillStyle = pillarColor;
    ctx.fillRect(o.x, 0, width, o.top);
   
    // Calculate logo size, making it 80% of the pillar's width
    const logoSize = width * 0.8;
    const logoX = o.x + (width - logoSize) / 2; // Center the logo horizontally
    const logoY = (o.top - logoSize) / 2; // Center the logo vertically
   
    // Draw the Roshen logo on the top pillar if the image is loaded
    if (roshenLogoImage.complete) {
        ctx.drawImage(roshenLogoImage, logoX, logoY, logoSize, logoSize);
    }
    // --- Bottom Pillar ---
    const bottomHeight = canvas.height - (o.top + gap);
    ctx.fillStyle = pillarColor;
    ctx.fillRect(o.x, o.top + gap, width, bottomHeight);
    // Calculate logo position for the bottom pillar
    const logoYBottom = o.top + gap + (bottomHeight - logoSize) / 2;
   
    // Draw the Roshen logo on the bottom pillar
    if (roshenLogoImage.complete) {
        ctx.drawImage(roshenLogoImage, logoX, logoYBottom, logoSize, logoSize);
    }
}
// ##########################
// Setup and Game Logic
// ##########################
let planeMask = [];
let planeAspect = 1.0; // Default aspect ratio
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: true });
ctx.imageSmoothingEnabled = false;
const scoreElement = document.querySelector('.score');
const startScreen = document.querySelector('.start-screen');
const startButton = document.querySelector('.start-button');
const startScreenTitle = startScreen.querySelector('h1');
const startScreenP = document.getElementById('start-screen-p');
const charSelectionContainer = document.querySelector('.character-selection');
const charButtons = document.querySelectorAll('.char-button');
/* Game State */
let gameOver = false;
let gameStarted = false;
let score = 0;
let frames = 0;
let cityBackground = null;
let gameSpeed = 2.0;
/* Player object */
let plane = {
  x: 0, y: 0, width: 0, height: 0,
  gravity: 0.25, lift: -5, velocity: 0, rotation: 0,
  draw() { if (!imageLoaded) return; ctx.save(); ctx.translate(this.x + this.width / 2, this.y + this.height / 2); ctx.rotate(this.rotation); ctx.drawImage(planeImage, -this.width / 2, -this.height / 2, this.width, this.height); ctx.restore(); },
  flap() { this.velocity = this.lift; },
  update() { this.velocity += this.gravity; this.y += this.velocity; this.rotation = Math.min(Math.max(this.velocity / (canvas.height * 0.04), -0.4), 0.7); if (this.y + this.height > canvas.height || this.y < 0) setGameOver(); }
};
/* Obstacles object */
const obstacles = {
  list: [],
  width: 0,
  gap: 0,
  spawnInterval: 110,
  spawn() { if (frames % this.spawnInterval === 0) { const minTop = Math.max(50, Math.floor(canvas.height * 0.1)); const maxTop = Math.floor(canvas.height - this.gap - canvas.height * 0.25); const topHeight = Math.floor(Math.random() * (maxTop - minTop + 1)) + minTop; this.list.push({ x: canvas.width, top: topHeight, passed: false }); } },
  update() { for (const o of this.list) { o.x -= gameSpeed; if (!o.passed && plane.x > o.x + this.width) { o.passed = true; score++; scoreElement.textContent = `CЧЕТ: ${score}`; gameSpeed = Math.min(gameSpeed + 0.1, 1000.0); obstacles.spawnInterval = Math.max(90, Math.floor((obstacles.width + canvas.width * 0.25) / gameSpeed)); } const planeRect = { x: plane.x, y: plane.y, width: plane.width, height: plane.height }; const topRect = { x: o.x, y: 0, width: this.width, height: o.top }; const bottomRect = { x: o.x, y: o.top + this.gap, width: this.width, height: canvas.height - (o.top + this.gap) }; if (rectsOverlap(planeRect, topRect) || rectsOverlap(planeRect, bottomRect)) { if (pixelPerfectAgainstRect(planeRect, planeMask, topRect) || pixelPerfectAgainstRect(planeRect, planeMask, bottomRect)) { setGameOver(); } } } this.list = this.list.filter(o => o.x + this.width > 0); },
  draw() {
    if (!selectedCharacter) return;
    const drawFunc = characterConfigs[selectedCharacter].drawObstacle;
    for (const o of this.list) {
        drawFunc(ctx, o, this.width, this.gap);
    }
  }
};
/* Utility & Collision */
function createMask(image) { const offCanvas = document.createElement('canvas'); offCanvas.width = image.width; offCanvas.height = image.height; const offCtx = offCanvas.getContext('2d'); offCtx.imageSmoothingEnabled = false; offCtx.drawImage(image, 0, 0); const data = offCtx.getImageData(0, 0, image.width, image.height).data; const mask = new Array(image.width * image.height); let m = 0; for (let i = 0; i < data.length; i += 4) { mask[m++] = data[i + 3] > 0; } return mask; }
function rectsOverlap(a, b) { return !(a.x + a.width <= b.x || a.x >= b.x + b.width || a.y + a.height <= b.y || a.y >= b.y + b.height); }
function pixelPerfectAgainstRect(planeRect, planeMask, rect) { if (!rectsOverlap(planeRect, rect)) return false; const startX = Math.max(planeRect.x, rect.x); const startY = Math.max(planeRect.y, rect.y); const endX = Math.min(planeRect.x + planeRect.width, rect.x + rect.width); const endY = Math.min(planeRect.y + planeRect.height, rect.y + rect.height); const sx = planeImage.width / planeRect.width; const sy = planeImage.height / planeRect.height; for (let y = startY; y < endY; y++) { const ay = Math.floor((y - planeRect.y) * sy); if (ay < 0 || ay >= planeImage.height) continue; for (let x = startX; x < endX; x++) { const ax = Math.floor((x - planeRect.x) * sx); if (ax < 0 || ax >= planeImage.width) continue; if (planeMask[ay * planeImage.width + ax]) { return true; } } } return false; }
/* Background */
function createCityBackground() { const bgCanvas = document.createElement('canvas'); bgCanvas.width = canvas.width; bgCanvas.height = canvas.height; const bgCtx = bgCanvas.getContext('2d'); bgCtx.imageSmoothingEnabled = false; const gradient = bgCtx.createLinearGradient(0, 0, 0, bgCanvas.height); gradient.addColorStop(0, '#4a7db9'); gradient.addColorStop(0.7, '#87CEEB'); bgCtx.fillStyle = gradient; bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height); bgCtx.fillStyle = '#ffdd00'; const sunR = Math.max(20, Math.floor(bgCanvas.width * 0.06)); bgCtx.beginPath(); bgCtx.arc(Math.floor(bgCanvas.width * 0.8), Math.floor(bgCanvas.height * 0.14), sunR, 0, Math.PI * 2); bgCtx.fill(); bgCtx.fillStyle = '#2c3e50'; for (let i = 0; i < bgCanvas.width; i += Math.max(30, Math.floor(bgCanvas.width * 0.08))) { const h = Math.floor(bgCanvas.height * (0.10 + Math.random() * 0.15)); const w = Math.max(25, Math.floor(bgCanvas.width * 0.07)); bgCtx.fillRect(i, bgCanvas.height - Math.floor(bgCanvas.height * 0.20) - h, w, h); } bgCtx.fillStyle = '#34495e'; for (let i = 0; i < bgCanvas.width; i += Math.max(22, Math.floor(bgCanvas.width * 0.06))) { const h = Math.floor(bgCanvas.height * (0.07 + Math.random() * 0.10)); const w = Math.max(18, Math.floor(bgCanvas.width * 0.05)); bgCtx.fillRect(i, bgCanvas.height - Math.floor(bgCanvas.height * 0.13) - h, w, h); } bgCtx.fillStyle = '#3498db'; bgCtx.fillRect(0, bgCanvas.height - Math.floor(bgCanvas.height * 0.035), bgCanvas.width, Math.floor(bgCanvas.height * 0.035)); return bgCanvas; }
/* Resize / Scale */
function sizeEverything() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const baseW = canvas.width;
    const baseH = canvas.height;
    const config = characterConfigs[selectedCharacter || 'benya'];
    gameSpeed = Math.max(2.2, baseW * 0.0045);
    plane.width = Math.max(40, Math.floor(baseW * 0.15));
    plane.height = Math.max(24, Math.floor(plane.width * planeAspect));
    if (!gameStarted) {
        plane.x = Math.floor(baseW * 0.17);
        plane.y = Math.floor(baseH * 0.45);
    }
    plane.gravity = Math.max(0.15, baseH * 0.00045) * config.gravityMultiplier;
    plane.lift = -Math.max(4, Math.floor(baseH * 0.01)) * config.liftMultiplier;
    obstacles.width = Math.max(50, Math.floor(baseW * 0.14));
    obstacles.gap = Math.max(120, Math.floor(baseH * 0.28));
    obstacles.spawnInterval = Math.max(90, Math.floor((obstacles.width + baseW * 0.25) / gameSpeed));
    cityBackground = createCityBackground();
    drawIdle();
}
function drawIdle() {
  ctx.drawImage(cityBackground, 0, 0);
  if (imageLoaded) plane.draw();
}
/* Game Flow */
function setGameOver() { if (gameOver) return; gameOver = true; const config = characterConfigs[selectedCharacter]; startScreenTitle.textContent = config.gameOverText; startScreenP.textContent = `СЧЕТ: ${score}. Нажмите на экран чтобы начать заново`; startButton.style.display = 'none'; charSelectionContainer.style.display = 'none'; startScreen.style.display = 'flex'; try { if (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.game) { window.Telegram.WebApp.ready(); window.Telegram.WebApp.game.setScore({ score }); } } catch (_) {} }
function resetGame() { obstacles.list = []; gameOver = false; score = 0; frames = 0; scoreElement.textContent = `СЧЕТ: ${score}`; startScreen.style.display = 'none'; plane.velocity = 0; plane.rotation = 0; plane.y = Math.floor(canvas.height * 0.45); gameSpeed = Math.max(2.2, canvas.width * 0.0045); obstacles.spawnInterval = Math.max(90, Math.floor((obstacles.width + canvas.width * 0.25) / gameSpeed)); if (!gameStarted) { gameStarted = true; } if (window.Telegram && window.Telegram.WebApp) { Telegram.WebApp.expand(); } loop(); }
/* Main loop */
function loop() { if (gameOver) return; ctx.drawImage(cityBackground, 0, 0); obstacles.spawn(); obstacles.update(); obstacles.draw(); plane.update(); plane.draw(); frames++; requestAnimationFrame(loop); }
// ##########################
// MODIFIED: Input Handling
// Now accounts for loading multiple assets before starting.
// ##########################
function handleGameInput() {
  if (!gameStarted && selectedCharacter && imageLoaded) {
    resetGame();
    return;
  }
  if (gameStarted && !gameOver) {
    plane.flap();
  }
  if (gameOver) {
    resetGame();
    return;
  }
}
function selectCharacter(charKey) {
    if (!characterConfigs[charKey]) return;

    selectedCharacter = charKey;
    const config = characterConfigs[selectedCharacter];

    // Update UI
    charButtons.forEach(b => b.classList.remove('selected'));
    document
        .querySelector(`.char-button[data-char="${charKey}"]`)
        .classList.add('selected');
    charSelectionContainer.style.display = 'none';
    startScreenP.textContent = `Вы выбрали: ${config.name}. Загрузка...`;
    startButton.style.display = 'none';

    // Reset counters
    assetsLoaded = 0;
    imageLoaded = false;
    assetsToLoad = (charKey === "porox") ? 2 : 1;

    // Attach handlers BEFORE src
    planeImage.onload = assetLoaded;
    planeImage.onerror = () => {
        console.error("Failed to load plane image: " + config.imageSrc);
        startScreenP.textContent = `Ошибка загрузки: ${config.imageSrc}`;
    };
    planeImage.src = config.imageSrc;

    if (charKey === "porox") {
        roshenLogoImage.onload = assetLoaded;
        roshenLogoImage.onerror = () => {
            console.error("Failed to load roshen logo");
            startScreenP.textContent = "Ошибка загрузки Roshen";
        };
        roshenLogoImage.src = "roshen-logo.png";
    }

    // Force trigger if already cached *and* has valid dimensions
    if (planeImage.complete && planeImage.naturalWidth > 0) assetLoaded();
    if (
        charKey === "porox" &&
        roshenLogoImage.complete &&
        roshenLogoImage.naturalWidth > 0
    ) {
        assetLoaded();
    }
}

charButtons.forEach(button => {
    button.addEventListener('click', (e) => {
        e.stopPropagation();
        const charKey = button.dataset.char;
        selectCharacter(charKey);
    });
});
document.addEventListener('click', handleGameInput);
document.addEventListener('touchstart', (e) => {
  if (gameStarted || gameOver || (selectedCharacter && imageLoaded)) {
    e.preventDefault();
  }
  handleGameInput();
}, { passive: false });
/* Init & Resize */
window.addEventListener('resize', sizeEverything);
window.addEventListener('orientationchange', () => {
  setTimeout(sizeEverything, 250);
});
/* First layout */
sizeEverything();

if (window.Telegram && window.Telegram.WebApp) {
  Telegram.WebApp.ready();
  Telegram.WebApp.expand();
}
</script>
</body>
</html>
